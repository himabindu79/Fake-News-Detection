# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'viewall.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report
import re
import string
from sklearn.metrics import confusion_matrix
from sklearn import metrics


class Ui_Form6(object):
    def __init__(self,text1):
              self.text1=text1
    def copy(self):
          #importing dataset
          df_fake = pd.read_csv("Fake.csv",)
          df_true = pd.read_csv("True.csv")


          #Inserting a column "class" as target feature
          df_fake["class"] = 0
          df_true["class"] = 1
          # Removing last 10 rows for manual testing
          df_fake_manual_testing = df_fake.tail(10)
          for i in range(23480,23470,-1):
                 df_fake.drop([i], axis = 0, inplace = True)
    
    
          df_true_manual_testing = df_true.tail(10)
          for i in range(21416,21406,-1):
                  df_true.drop([i], axis = 0, inplace = True)

          df_fake_manual_testing["class"] = 0
          df_true_manual_testing["class"] = 1 


          df_manual_testing = pd.concat([df_fake_manual_testing,df_true_manual_testing], axis = 0)
          df_manual_testing.to_csv("manual_testing.csv")

          #Merging True and Fake Dataframes
          df_merge = pd.concat([df_fake, df_true], axis =0 )
          df_merge.columns
          #Removing columns which are not required
          df = df_merge.drop(["title", "subject","date"], axis = 1)
          print(df.isnull().sum())

          #Random Shuffling the dataframe
          df = df.sample(frac = 1)


          df.reset_index(inplace = True)
          df.drop(["index"], axis = 1, inplace = True)
          #Creating a function to process the texts
          def wordopt(text):
                  text = text.lower()
                  text = re.sub('\[.*?\]', '', text)
                  text = re.sub("\\W"," ",text) 
                  text = re.sub('https?://\S+|www\.\S+', '', text)
                  text = re.sub('<.*?>+', '', text)
                  text = re.sub('[%s]' % re.escape(string.punctuation), '', text)
                  text = re.sub('\n', '', text)
                  text = re.sub('\w*\d\w*', '', text)    
                  return text
          df["text"] = df["text"].apply(wordopt)
          #Defining dependent and independent variables
          x = df["text"]
          y = df["class"]
          x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.25)

          #Convert text to vectors
          from sklearn.feature_extraction.text import TfidfVectorizer
          vectorization = TfidfVectorizer()
          xv_train = vectorization.fit_transform(x_train)
          xv_test = vectorization.transform(x_test)
          #logestic Regression
          from sklearn.linear_model import LogisticRegression

          LR = LogisticRegression()
          LR.fit(xv_train,y_train)
          pred_lr=LR.predict(xv_test)
          lcm=confusion_matrix(y_test,pred_lr)
          fig, ax = plt.subplots(figsize=(8, 8))
          ax.imshow(lcm)
          ax.grid(False)
          ax.xaxis.set(ticks=(0, 1), ticklabels=('Predicted 0s', 'Predicted 1s'))
          ax.yaxis.set(ticks=(0, 1), ticklabels=('Actual 0s', 'Actual 1s'))
          ax.set_ylim(1.5, -0.5)
          for i in range(2):
              for j in range(2):
                      ax.text(j, i, lcm[i, j], ha='center', va='center', color='red')
                   
          plt.show()
          y_pred_proba = LR.predict_proba(xv_test)[::,1]
          fpr, tpr, _ = metrics.roc_curve(y_test,  y_pred_proba)
          auc = metrics.roc_auc_score(y_test, y_pred_proba)
          plt.plot(fpr,tpr,label="data 1, auc="+str(auc))
          plt.legend(loc=4)
          plt.show()
          #Decession Tree
          from sklearn.tree import DecisionTreeClassifier

          DT = DecisionTreeClassifier(random_state=1234)
          DT.fit(xv_train, y_train)

          pred_dt = DT.predict(xv_test)
          dcm=confusion_matrix(y_test,pred_dt)
          fig, ax = plt.subplots(figsize=(8, 8))
          ax.imshow(dcm)
          ax.grid(False)
          ax.xaxis.set(ticks=(0, 1), ticklabels=('Predicted Fake', 'Predicted True'))
          ax.yaxis.set(ticks=(0, 1), ticklabels=('Actual 0s', 'Actual 1s'))
          ax.set_ylim(1.5, -0.5)
          for i in range(2):
               for j in range(2):
                     ax.text(j, i, dcm[i, j], ha='center', va='center', color='red')
          plt.show()
          #Gradient Boosting Classifier
          from sklearn.ensemble import GradientBoostingClassifier

          GBC = GradientBoostingClassifier(random_state=0)
          GBC.fit(xv_train, y_train)

          pred_gbc = GBC.predict(xv_test)

          gcm=confusion_matrix(y_test,pred_gbc)
          fig, ax = plt.subplots(figsize=(8, 8))
          ax.imshow(gcm)
          ax.grid(False)
          ax.xaxis.set(ticks=(0, 1), ticklabels=('Predicted Fake', 'Predicted True'))
          ax.yaxis.set(ticks=(0, 1), ticklabels=('Actual Fake', 'Actual True'))
          ax.set_ylim(1.5, -0.5)
          for i in range(2):
              for j in range(2):
                     ax.text(j, i, gcm[i, j], ha='center', va='center', color='red')
          plt.show()
          #Random Forest Classifier
          from sklearn.ensemble import RandomForestClassifier

          RFC = RandomForestClassifier(random_state=0)
          RFC.fit(xv_train, y_train)

          pred_rfc = RFC.predict(xv_test)
          rcm=confusion_matrix(y_test,pred_rfc)
          fig, ax = plt.subplots(figsize=(8, 8))
          ax.imshow(rcm)
          ax.grid(False)
          ax.xaxis.set(ticks=(0, 1), ticklabels=('Predicted Fake', 'Predicted True'))
          ax.yaxis.set(ticks=(0, 1), ticklabels=('Actual 0s', 'Actual 1s'))
          ax.set_ylim(1.5, -0.5)
          for i in range(2):
              for j in range(2):
                     ax.text(j, i, rcm[i, j], ha='center', va='center', color='red')
          plt.show()
          #Passive Aggressive Classifier
          from sklearn.linear_model import PassiveAggressiveClassifier
          PAAG = PassiveAggressiveClassifier()
          PAAG.fit(xv_train, y_train)

          pred_paag = PAAG.predict(xv_test)



          pcm=confusion_matrix(y_test,pred_paag)
          fig, ax = plt.subplots(figsize=(8, 8))
          ax.imshow(pcm)
          ax.grid(False)
          ax.xaxis.set(ticks=(0, 1), ticklabels=('Predicted Fake', 'Predicted True'))
          ax.yaxis.set(ticks=(0, 1), ticklabels=('Actual 0s', 'Actual 1s'))
          ax.set_ylim(1.5, -0.5)
          for i in range(2):
              for j in range(2):
                     ax.text(j, i, pcm[i, j], ha='center', va='center', color='red')
          plt.show()
          #Model Testing
          def output_lable(n):
                 if n == 0:
                     return "Fake News"
                 elif n == 1:
                     return "Not A Fake News"
          def manual_testing(news):
                    testing_news = {"text":[news]}
                    new_def_test = pd.DataFrame(testing_news)
                    new_def_test["text"] = new_def_test["text"].apply(wordopt) 
                    new_x_test = new_def_test["text"]
                    new_xv_test = vectorization.transform(new_x_test)
                    pred_LR = LR.predict(new_xv_test)
                    pred_DT = DT.predict(new_xv_test)
                    pred_GBC = GBC.predict(new_xv_test)
                    pred_RFC = RFC.predict(new_xv_test)
                    pred_PAAG = PAAG.predict(new_xv_test)
   
    
    
                    self.logestic.setText("Logistic Regression Prediction: {} \nresult:\n{} \n\nTesting Accuracy : {:.2f} \n\nConfusion Matrix: \n{}" .format(output_lable(pred_LR[0]),
                                                                                                                                                     classification_report(y_test, pred_lr),
                                                                                                                                                     (accuracy_score(y_test,pred_lr)*100),
                                                                                                                                                      lcm))
                    self.decessiontree_2.setText("Decision Tree Prediction: {} \nresult:\n{} \n\nTesting Accuracy : {:.2f} \n\nConfusion Matrix: \n{}" .format(output_lable(pred_DT[0]),
                                                                                                                                                    classification_report(y_test, pred_dt),
                                                                                                                                                    (accuracy_score(y_test,pred_dt)*100),
                                                                                                                                                     dcm))
                                                                                                      
                    self.gradient.setText("Gradient Boosting Prediction: {} \nresult:\n{} \n\nTesting Accuracy : {:.2f} \n\nConfusion Matrix: \n{}" .format(output_lable(pred_GBC[0]),
                                                                                                                                                    classification_report(y_test, pred_gbc),
                                                                                                                                                    (accuracy_score(y_test,pred_gbc)*100),
                                                                                                                                                     gcm))
                    
                    
                    self.random.setText("Random Forest Prediction: {} \nresult:\n{} \n\nTesting Accuracy : {:.2f} \n\nConfusion Matrix: \n{}" .format(output_lable(pred_RFC[0]),
                                                                                                                                                   classification_report(y_test, pred_rfc),
                                                                                                                                                   (accuracy_score(y_test,pred_rfc)*100),
                                                                                                                                                    rcm))
                    self.passive.setText("Passive Aggressive Prediction: {} \nresult:\n{} \n\nTesting Accuracy : {:.2f} \n\nConfusion Matrix: \n{}" .format(output_lable(pred_PAAG[0]),
                                                                                                                                                         classification_report(y_test, pred_paag),
                                                                                                                                                         (accuracy_score(y_test,pred_paag)*100),
                                                                                                                                                          pcm))
                   
          news = str(self.text1)
          manual_testing(news)          
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1094, 739)
        self.graphicsView = QtWidgets.QGraphicsView(Form)
        self.graphicsView.setGeometry(QtCore.QRect(0, 0, 1431, 781))
        self.graphicsView.setObjectName("graphicsView")
        self.logestic = QtWidgets.QLabel(Form)
        self.logestic.setGeometry(QtCore.QRect(30, 30, 300, 300))
        self.logestic.setFrameShape(QtWidgets.QFrame.Box)
        self.logestic.setText("")
        self.logestic.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.logestic.setObjectName("logestic")
        self.gradient = QtWidgets.QLabel(Form)
        self.gradient.setGeometry(QtCore.QRect(30, 400, 300, 300))
        self.gradient.setFrameShape(QtWidgets.QFrame.Box)
        self.gradient.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.gradient.setObjectName("gradient")
        self.decessiontree_2 = QtWidgets.QLabel(Form)
        self.decessiontree_2.setGeometry(QtCore.QRect(400, 30, 300, 300))
        self.decessiontree_2.setFrameShape(QtWidgets.QFrame.Box)
        self.decessiontree_2.setText("")
        self.decessiontree_2.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.decessiontree_2.setObjectName("decessiontree_2")
        self.random = QtWidgets.QLabel(Form)
        self.random.setGeometry(QtCore.QRect(400, 400, 300, 300))
        self.random.setFrameShape(QtWidgets.QFrame.Box)
        self.random.setText("")
        self.random.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.random.setObjectName("random")
        self.passive = QtWidgets.QLabel(Form)
        self.passive.setGeometry(QtCore.QRect(773, 28, 300, 300))
        self.passive.setFrameShape(QtWidgets.QFrame.Box)
        self.passive.setText("")
        self.passive.setObjectName("passive")
        self.copy()

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "viewall"))
        


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Form = QtWidgets.QWidget()
    ui = Ui_Form6()
    ui.setupUi(Form)
    Form.show()
    sys.exit(app.exec_())
